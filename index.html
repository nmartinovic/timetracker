<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Time Tracker</title>
  <style>
    /* ===== Design tokens ===== */
    :root{
      --bg: #f6f7fb;
      --card: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --border: #e5e7eb;
      --primary: #2563eb;
      --primary-600: #1d4ed8;
      --primary-50: #eff6ff;
      --accent: #10b981;
      --warn: #ef4444;
      --radius: 14px;
      --shadow: 0 12px 30px rgba(0,0,0,.08);
      --shadow-sm: 0 6px 18px rgba(0,0,0,.06);
    }
    @media (prefers-color-scheme: dark){
      :root{
        --bg: #0f172a;
        --card: #111827;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --border: #1f2937;
        --primary: #60a5fa;
        --primary-600: #3b82f6;
        --primary-50: #0b1220;
        --accent: #34d399;
        --shadow: 0 12px 30px rgba(0,0,0,.35);
        --shadow-sm: 0 6px 18px rgba(0,0,0,.3);
      }
    }

    *, *::before, *::after { box-sizing: border-box; }
    html,body{height:100%}
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif;
      color:var(--text); background:
        radial-gradient(1200px 1200px at 10% -10%, rgba(37,99,235,.08), transparent 40%),
        radial-gradient(1200px 1200px at 110% 10%, rgba(16,185,129,.06), transparent 40%),
        var(--bg);
    }
    .container{ max-width: 1100px; margin: 28px auto; padding: 0 16px; }
    .header{ display:flex; align-items: center; gap:14px; margin-bottom: 18px; }
    .logo{
      width:40px; height:40px; border-radius: 10px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
      box-shadow: var(--shadow-sm);
      display:flex; align-items:center; justify-content:center; color:white; font-weight:700;
    }
    .title h1{margin:0; font-size: clamp(20px, 3vw, 28px);}
    .title p{margin:2px 0 0; color:var(--muted); font-size: 14px}

    .grid{ display:grid; gap:16px; grid-template-columns: 1fr; }
    @media (min-width: 980px){
      .grid{
        grid-template-columns: minmax(340px, 420px) minmax(520px, 640px);
        justify-content: center; max-width: 1080px; margin-inline: auto;
      }
    }

    .card{
      background: var(--card); border:1px solid var(--border);
      border-radius: var(--radius); box-shadow: var(--shadow); padding:18px;
    }
    .section-title{ display:flex; align-items:center; justify-content: space-between; gap:10px; margin-bottom:12px; }
    .section-title h2{margin:0; font-size:18px}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    label{font-size:14px; color:var(--muted)}
    input[type="text"], input[type="number"]{
      border:1px solid var(--border); background:transparent; color:var(--text);
      padding:10px 12px; border-radius:10px; outline:none; min-width: 0;
    }
    input::placeholder{color:var(--muted)}

    .btn{
      border:1px solid var(--border);
      background: var(--card);
      color: var(--text);
      padding:10px 14px; border-radius: 10px;
      cursor:pointer; transition: transform .04s ease, background .2s ease, border-color .2s ease;
      box-shadow: var(--shadow-sm);
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn:active{ transform: translateY(0); }
    .btn-primary{
      background: linear-gradient(180deg, var(--primary), var(--primary-600));
      border-color: transparent; color: white;
    }
    .btn-ghost{ background: transparent; }
    .btn-warn{
      border-color: color-mix(in oklab, var(--warn), black 10%);
      color: var(--warn);
      background: color-mix(in oklab, var(--warn), transparent 92%);
    }
    .badge{
      font-size:12px; padding:4px 10px; border-radius:999px; border:1px solid var(--border); color:var(--muted);
      background: color-mix(in oklab, var(--primary-50), transparent 60%);
    }
    .badge.on{ color:#059669; border-color: #10b98144; background: #10b98111; }
    .badge.off{ color:#b91c1c; border-color: #ef444444; background: #ef444411; }

    .countdown{
      font-size: clamp(32px, 6vw, 48px);
      font-weight: 800; letter-spacing: 1px;
      padding: 10px 14px; border-radius: 12px;
      background: linear-gradient(to right, var(--primary-50), transparent);
      border:1px solid var(--border);
      display:inline-block; margin-top: 6px;
    }
    .hint{ color:var(--muted); font-size:12px; margin-top:4px }

    table{ width:100%; border-collapse: collapse; }
    thead th{
      text-align:left; font-size:12px; color:var(--muted); font-weight:600;
      border-bottom:1px solid var(--border); padding:10px 8px;
      position: sticky; top:0; background: var(--card);
    }
    tbody td{ border-bottom:1px solid var(--border); padding: 10px 8px; vertical-align: top; }
    tbody tr:hover{ background: color-mix(in oklab, var(--primary-50), transparent 85%); }

    #chartWrap{ display:none; margin-top:12px; }
    #barChart{
      width:100%; height:auto; border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(99,102,241,0.04), transparent);
      border-radius: 12px; box-shadow: var(--shadow-sm);
    }
    .chart-note{ font-size:12px; color:var(--muted); margin-top:6px }

    .modal-backdrop{ position:fixed; inset:0; display:none; place-items:center; background: rgba(0,0,0,.45); z-index: 50;}
    .modal{
      width:min(520px, 92vw); background: var(--card); color:var(--text);
      border:1px solid var(--border); border-radius: 16px; box-shadow: var(--shadow);
      padding:18px; animation: pop .14s ease-out;
    }
    @keyframes pop{ from{transform: scale(.98); opacity:.8} to{transform: scale(1); opacity:1} }
    .modal h3{ margin:0 0 10px }
    .modal .row{ display:grid; grid-template-columns: 140px 1fr; gap:10px; align-items:center }
    .modal .actions{ display:flex; gap:10px; justify-content: end; margin-top:12px }

    code{ background: color-mix(in oklab, var(--primary-50), transparent 70%); padding:2px 6px; border-radius:6px; }
    .spacer{ height:8px }
    .nowrap{ white-space: nowrap }
    .actions-col{ white-space: nowrap }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">TT</div>
      <div class="title">
        <h1>Time Tracker</h1>
        <p>Lightweight, offline, and export-friendly.</p>
      </div>
    </div>

    <div class="grid">
      <!-- Left: controls -->
      <div class="card">
        <div class="section-title"><h2>Timer</h2></div>
        <div class="row">
          <label class="nowrap">Task</label>
          <input id="task" type="text" placeholder="What are you working on?" style="flex:1" />
        </div>
        <div class="row">
          <label class="nowrap">Duration (min)</label>
          <input id="duration" type="number" value="25" min="1" style="width:120px" />
        </div>
        <div class="row" style="gap:8px; margin-top:6px">
          <button class="btn btn-primary" onclick="startTimer()">Start</button>
          <button class="btn" onclick="startCountUp()">Count Up</button>
          <button class="btn" onclick="stopTimer(true)">Stop</button>
          <span class="countdown" id="countdown">00:00</span>
        </div>
        <div class="hint" id="nextReminderETA"></div>

        <div class="spacer"></div>
        <div class="row" style="gap:8px; flex-wrap:wrap">
          <button class="btn" onclick="exportCSV()">Export CSV</button>
          <button class="btn btn-warn" onclick="clearHistory()">Clear History</button>
          <button class="btn btn-ghost" onclick="openAddModal()">Add Past Session</button>
        </div>

        <div class="spacer"></div>
        <div class="row" style="gap:8px; flex-wrap:wrap">
          <button class="btn" id="muteSoundBtn" onclick="toggleMuteSound()">Mute Sound</button>
          <span id="muteSoundBadge" class="badge on">Sound: On</span>

          <button class="btn" id="muteNotifBtn" onclick="toggleMuteNotifications()">Disable Notifications</button>
          <span id="muteNotifBadge" class="badge on">Notifications: On</span>

          <button class="btn" id="muteRemindersBtn" onclick="toggleMuteReminders()">Mute Reminders</button>
          <span id="muteRemindersBadge" class="badge on">Reminders: On</span>
        </div>

        <div class="spacer"></div>
        <!-- Display Timezone controls -->
        <div class="row" style="gap:8px; flex-wrap:wrap">
          <label class="nowrap">Display Timezone</label>
          <input id="tzInput" type="text" list="tzList" placeholder="e.g., Europe/Paris" style="width:220px" />
          <datalist id="tzList">
            <option value="UTC"></option>
            <option value="Europe/Paris"></option>
            <option value="Europe/London"></option>
            <option value="Europe/Berlin"></option>
            <option value="America/New_York"></option>
            <option value="America/Chicago"></option>
            <option value="America/Denver"></option>
            <option value="America/Los_Angeles"></option>
            <option value="America/Sao_Paulo"></option>
            <option value="Asia/Tokyo"></option>
            <option value="Asia/Shanghai"></option>
            <option value="Asia/Kolkata"></option>
            <option value="Australia/Sydney"></option>
            <option value="Pacific/Auckland"></option>
          </datalist>
          <button class="btn" onclick="applyTimezone()">Apply</button>
          <button class="btn btn-ghost" onclick="useSystemTimezone()">Use System</button>
          <span id="tzBadge" class="badge">TZ: —</span>
        </div>
      </div>

      <!-- Right: chart + history -->
      <div class="card">
        <div class="section-title">
          <h2>Insights</h2>
          <div class="row">
            <button class="btn btn-ghost" onclick="toggleChart()">Show Chart</button>
          </div>
        </div>
        <div id="chartWrap">
          <canvas id="barChart" width="900" height="280"></canvas>
          <div class="chart-note" id="chartNote">Minutes per day for the last five weekdays.</div>
        </div>

        <div class="section-title" style="margin-top:18px"><h2>Session History</h2></div>
        <div style="max-height: 440px; overflow:auto; border:1px solid var(--border); border-radius: 12px">
          <table class="log-table" id="logTable">
            <thead>
              <tr>
                <th>Task</th>
                <th class="nowrap">Duration</th>
                <th class="nowrap" id="startHeader">Start</th>
                <th class="nowrap" id="endHeader">End</th>
                <th class="actions-col">Actions</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

      </div>
    </div>
  </div>

  <!-- Modal: Add/Edit -->
  <div id="modalBackdrop" class="modal-backdrop">
    <div class="modal">
      <h3 id="modalTitle">Edit Session</h3>
      <div class="row">
        <label for="modalTask">Task</label>
        <input id="modalTask" type="text" placeholder="Task name" />
      </div>
      <div class="row">
        <label for="modalStart">Start (UTC)</label>
        <input id="modalStart" type="text" placeholder="YYYY-MM-DD HH:MM:SS" />
      </div>
      <div class="row">
        <label for="modalEnd">End (UTC)</label>
        <input id="modalEnd" type="text" placeholder="YYYY-MM-DD HH:MM:SS" />
      </div>
      <div class="hint">Times must be UTC, e.g., <code>2025-03-01 09:30:00</code>.</div>
      <div class="actions">
        <button class="btn btn-ghost" onclick="closeModal()">Cancel</button>
        <button class="btn btn-ghost btn-warn" id="modalDeleteBtn" onclick="deleteSessionFromModal()" style="display:none">Delete</button>
        <button class="btn btn-primary" onclick="saveModal()">Save</button>
      </div>
    </div>
  </div>

  <audio id="ding" src="https://actions.google.com/sounds/v1/alarms/digital_watch_alarm_long.ogg" preload="auto"></audio>

  <script>
    /* ========= State ========= */
    let timer = null;
    let timerMode = null; // 'down' | 'up' | null
    let endTime = null;
    let startTime = null;
    let currentTask = null;
    let currentDuration = null;
    let dingTimeout = null;

    // Count-up reminder state
    const UP_REM_MS = 20 * 60 * 1000;
    let nextUpReminderAt = null;

    // Mutes
    let muteSound = JSON.parse(localStorage.getItem('muteSound') || 'false');
    let muteNotifications = JSON.parse(localStorage.getItem('muteNotifications') || 'false');
    let muteReminders = JSON.parse(localStorage.getItem('muteReminders') || 'false');

    // Idle reminder tracking
    let lastTimerActivity = parseInt(localStorage.getItem('lastTimerActivity') || String(Date.now()), 10);
    let idleCheckHandle = null;

    // Logging guard to avoid duplicates
    let hasLoggedCurrent = false;

    // Modal state
    let modalMode = 'edit'; // 'edit' | 'add'
    let modalEditingId = null;

    // Display timezone
    function getSystemTZ() {
      try { return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC'; }
      catch(e){ return 'UTC'; }
    }
    let displayTZ = localStorage.getItem('displayTZ') || getSystemTZ();

    // ===== Active timer persistence =====
    function writeActiveTimer() {
      if (!startTime || !currentTask) return;
      const payload = {
        task: currentTask,
        startMs: startTime,
        endMs: endTime ?? null,
        hasLogged: !!hasLoggedCurrent,
        mode: timerMode || null,
        nextUpReminderAt: nextUpReminderAt ?? null
      };
      localStorage.setItem('active_timer', JSON.stringify(payload));
    }
    function clearActiveTimer() {
      localStorage.removeItem('active_timer');
    }
    function loadActiveTimer() {
      try { return JSON.parse(localStorage.getItem('active_timer') || 'null'); }
      catch(e){ return null; }
    }

    // ===== Optimization state =====
    let lastPersist = 0;
    const PERSIST_EVERY_MS = 5000; // throttle localStorage write
    let lastTitleText = '';
    let lastCountdownText = '';

    /* ========= Helpers ========= */
    function markActivity() {
      lastTimerActivity = Date.now();
      localStorage.setItem('lastTimerActivity', String(lastTimerActivity));
    }
    function formatTime(ms) {
      const totalSeconds = Math.max(0, Math.floor(Math.abs(ms) / 1000));
      const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
      const seconds = String(totalSeconds % 60).padStart(2, '0');
      return `${minutes}:${seconds}`;
    }
    function formatExcelDateString(dateObj) {
      return dateObj.toISOString().replace('T', ' ').split('.')[0]; // UTC-safe
    }
    function parseUTCString(s) {
      const m = s.trim().match(/^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})$/);
      if (!m) return null;
      const [_, Y,M,D,h,mn,sc] = m;
      const ms = Date.UTC(+Y, +M-1, +D, +h, +mn, +sc);
      const dt = new Date(ms);
      return isNaN(dt.getTime()) ? null : dt;
    }
    function durationStringFromDates(startDt, endDt) {
      const ms = Math.max(0, endDt - startDt);
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
    }
    function ensureIdsOnLog(log) {
      let changed = false;
      log.forEach(item => {
        if (!item.id) { item.id = 's_' + Date.now() + '_' + Math.random().toString(36).slice(2,8); changed = true; }
      });
      if (changed) localStorage.setItem('time_log', JSON.stringify(log));
    }
    function findLogIndexById(id) {
      const log = JSON.parse(localStorage.getItem('time_log') || '[]');
      return log.findIndex(x => x.id === id);
    }
    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }

    function formatInTZ(date, tz) {
      const dtf = new Intl.DateTimeFormat('en-CA', {
        timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit',
        hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
      });
      const parts = dtf.formatToParts(date);
      const get = t => parts.find(p => p.type === t)?.value || '00';
      return `${get('year')}-${get('month')}-${get('day')} ${get('hour')}:${get('minute')}:${get('second')}`;
    }
    function ymdInTZ(date, tz) {
      const dtf = new Intl.DateTimeFormat('en-CA', { timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit' });
      const parts = dtf.formatToParts(date);
      const get = t => parts.find(p => p.type === t)?.value || '00';
      return `${get('year')}-${get('month')}-${get('day')}`;
    }
    function isValidTimeZone(tz) {
      try { new Intl.DateTimeFormat('en-US', { timeZone: tz }); return true; }
      catch(e){ return false; }
    }

    // Work windows: 09:30–13:00 and 14:00–18:00 (Europe/Paris) — used only for idle reminders
    function inParisWorkWindows() {
      const nowParis = new Date(new Date().toLocaleString('en-US', { timeZone: 'Europe/Paris' }));
      const hh = nowParis.getHours();
      const mm = nowParis.getMinutes();
      const minutes = hh * 60 + mm;
      const morningStart = 9 * 60 + 30;
      const morningEnd   = 13 * 60;
      const aftStart     = 14 * 60;
      const aftEnd       = 18 * 60;
      return (minutes >= morningStart && minutes < morningEnd) || (minutes >= aftStart && minutes < aftEnd);
    }

    /* ========= Timer ========= */
    function startTimer() {
      const task = document.getElementById('task').value.trim();
      const minutes = parseInt(document.getElementById('duration').value, 10);
      if (!task || isNaN(minutes) || minutes < 1) return alert('Please enter a valid task and duration.');

      timerMode = 'down';
      startTime = Date.now();
      endTime = startTime + minutes * 60000;
      currentTask = task;
      currentDuration = minutes;
      hasLoggedCurrent = false;
      nextUpReminderAt = null; // not used in countdown

      updateTimerUI();
      markActivity();

      if (!muteNotifications && typeof Notification !== 'undefined' && Notification.permission !== 'granted') {
        Notification.requestPermission();
      }

      writeActiveTimer();
      lastPersist = 0;
      lastTitleText = ''; lastCountdownText = '';

      if (timer) clearInterval(timer);
      timer = setInterval(tick, 1000);
    }

    function startCountUp() {
      const task = document.getElementById('task').value.trim();
      if (!task) return alert('Please enter a task name.');

      timerMode = 'up';
      startTime = Date.now();
      endTime = null;
      currentTask = task;
      currentDuration = null;
      hasLoggedCurrent = false;
      nextUpReminderAt = startTime + UP_REM_MS; // first nudge in 20m

      updateTimerUI();
      markActivity();

      if (!muteNotifications && typeof Notification !== 'undefined' && Notification.permission !== 'granted') {
        Notification.requestPermission();
      }

      writeActiveTimer();
      lastPersist = 0;
      lastTitleText = ''; lastCountdownText = '';

      if (timer) clearInterval(timer);
      timer = setInterval(tick, 1000);
    }

    function stopTimer(log = false) {
      clearInterval(timer);
      timer = null;

      if (log && !hasLoggedCurrent && currentTask && startTime) {
        logSession(currentTask, Date.now());
        hasLoggedCurrent = true;
      }

      timerMode = null;
      endTime = null;
      startTime = null;
      currentTask = null;
      currentDuration = null;
      nextUpReminderAt = null;

      clearActiveTimer();

      document.getElementById('countdown').textContent = '00:00';
      document.title = 'Time Tracker';
      lastTitleText = 'Time Tracker';
      lastCountdownText = '00:00';

      markActivity();
      maybeRerenderChart();
    }

    function tick() {
      if (!startTime || !timerMode) return;
      const now = Date.now();

      if (timerMode === 'down') {
        const remaining = (endTime || 0) - now;
        updateTimerUI();
        if (remaining <= 0 && !hasLoggedCurrent) {
          notify(currentTask);
          logSession(currentTask, endTime);
          hasLoggedCurrent = true;
          stopTimer(false);
        }
      } else if (timerMode === 'up') {
        updateTimerUI();
        // 20-minute recurring reminder while counting up
        if (!muteReminders && !muteNotifications && typeof Notification !== 'undefined') {
          if (Notification.permission === 'granted' && nextUpReminderAt && now >= nextUpReminderAt) {
            new Notification('Timer still running', { body: `Task: ${currentTask} — ${formatTime(now - startTime)} elapsed` });
            // optional sound ping
            if (!muteSound) {
              const ding = document.getElementById('ding');
              try { ding.currentTime = 0; ding.play(); setTimeout(() => { try { ding.pause(); } catch(e){} }, 1000); } catch(e){}
            }
            nextUpReminderAt += UP_REM_MS;
            writeActiveTimer(); // persist updated reminder schedule
          }
        }
      }
    }

    function updateTimerUI() {
      if (!startTime || !timerMode) return;
      const now = Date.now();
      let timeString = '00:00';
      if (timerMode === 'down') {
        const remaining = Math.max(0, (endTime || 0) - now);
        timeString = formatTime(remaining);
      } else {
        const elapsed = Math.max(0, now - startTime);
        timeString = formatTime(elapsed);
      }

      // Avoid unnecessary DOM churn
      if (timeString !== lastCountdownText) {
        document.getElementById('countdown').textContent = timeString;
        lastCountdownText = timeString;
      }
      const title = (timerMode === 'up' ? `↑${timeString}` : `${timeString}`) + ' - Time Tracker';
      if (title !== lastTitleText) {
        document.title = title;
        lastTitleText = title;
      }

      // Throttle persistence
      if (now - lastPersist >= PERSIST_EVERY_MS) {
        writeActiveTimer();
        lastPersist = now;
      }
    }

    function notify(task) {
      if (!muteSound) {
        const ding = document.getElementById('ding');
        ding.currentTime = 0;
        ding.play();
        dingTimeout = setTimeout(() => { try { ding.pause(); } catch(e){} }, 3000);
      }
      if (!muteNotifications && typeof Notification !== 'undefined' && Notification.permission === 'granted') {
        new Notification('Time is up!', { body: `Task: ${task}` });
      }
    }

    // Log on page unload if finished and not yet logged (only applies to countdown)
    window.addEventListener('beforeunload', () => {
      try {
        if (timerMode === 'down' && !hasLoggedCurrent && startTime && endTime && Date.now() >= endTime) {
          logSession(currentTask, endTime);
          hasLoggedCurrent = true;
          writeActiveTimer();
        }
      } catch (e) {}
    });

    // Restore active timer on load (resume countdown or count-up)
    function restoreActiveTimer() {
      const saved = loadActiveTimer();
      if (!saved) return;

      currentTask = saved.task;
      startTime = saved.startMs;
      endTime = saved.endMs ?? null;
      hasLoggedCurrent = !!saved.hasLogged;
      timerMode = saved.mode || (endTime ? 'down' : 'up'); // backward-compat
      nextUpReminderAt = saved.nextUpReminderAt ?? null;

      // Reflect task in input
      const taskInput = document.getElementById('task');
      if (taskInput && typeof saved.task === 'string') taskInput.value = saved.task;

      if (!startTime || !currentTask) {
        clearActiveTimer(); return;
      }

      lastTitleText = ''; lastCountdownText = ''; // force repaint
      const now = Date.now();

      if (timerMode === 'up') {
        // If reminder schedule is stale or missing, set next to the next 20m boundary
        if (!nextUpReminderAt || nextUpReminderAt <= now) {
          const elapsedSinceStart = now - startTime;
          const intervalsPassed = Math.ceil(elapsedSinceStart / UP_REM_MS);
          nextUpReminderAt = startTime + intervalsPassed * UP_REM_MS;
        }
      }

      updateTimerUI();
      if (timer) clearInterval(timer);
      timer = setInterval(tick, 1000);

      // Auto-log ended countdown if reopened after it finished
      if (timerMode === 'down' && endTime && now >= endTime && !hasLoggedCurrent) {
        logSession(currentTask, endTime);
        hasLoggedCurrent = true;
        stopTimer(false);
      }
    }

    /* ========= Logging ========= */
    function logSession(task, endOverrideMs /* optional */) {
      if (!startTime) return;
      const start = new Date(startTime);
      const end = new Date(typeof endOverrideMs === 'number' ? endOverrideMs : Date.now());
      const duration = durationStringFromDates(start, end);

      // Store in UTC
      const session = {
        id: 's_' + Date.now() + '_' + Math.random().toString(36).slice(2,8),
        task,
        duration,
        start: formatExcelDateString(start) + ' UTC',
        end: formatExcelDateString(end) + ' UTC',
      };

      const log = JSON.parse(localStorage.getItem('time_log') || '[]');
      log.push(session);
      localStorage.setItem('time_log', JSON.stringify(log));
      renderLog();
      maybeRerenderChart();
    }

    function renderLog() {
      const log = JSON.parse(localStorage.getItem('time_log') || '[]');
      ensureIdsOnLog(log);

      document.getElementById('startHeader').textContent = `Start (${displayTZ})`;
      document.getElementById('endHeader').textContent = `End (${displayTZ})`;

      const tbody = document.querySelector('#logTable tbody');
      tbody.innerHTML = '';

      // Newest first
      log.slice().reverse().forEach(row => {
        const startUtc = (row.start || '').replace(' UTC','');
        const endUtc = (row.end || '').replace(' UTC','');
        const startDt = parseUTCString(startUtc);
        const endDt = parseUTCString(endUtc);
        const startDisp = startDt ? formatInTZ(startDt, displayTZ) : '';
        const endDisp = endDt ? formatInTZ(endDt, displayTZ) : '';

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${escapeHtml(row.task)}</td>
          <td class="nowrap">${row.duration}</td>
          <td class="nowrap">${startDisp}</td>
          <td class="nowrap">${endDisp}</td>
          <td class="actions-col">
            <button class="btn btn-ghost" onclick="openEditModal('${row.id}')">Edit</button>
          </td>
        `;
        tbody.appendChild(tr);
      });
    }

    /* ========= Export / Clear ========= */
    function exportCSV() {
      const log = JSON.parse(localStorage.getItem('time_log') || '[]');
      if (log.length === 0) return alert('No data to export.');
      const header = ['Task', 'Duration', 'Start (UTC)', 'End (UTC)'];
      const rows = log.map(r => [r.task, r.duration, r.start, r.end]);
      const csv = [header.join(','), ...rows.map(r => r.map(csvEscape).join(','))].join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'time_log.csv'; a.click();
      function csvEscape(v){
        const s = String(v ?? '');
        return (s.includes(',') || s.includes('"') || s.includes('\n')) ? '"' + s.replace(/"/g,'""') + '"' : s;
      }
    }
    function clearHistory() {
      if (confirm('Are you sure you want to delete all session history?')) {
        localStorage.removeItem('time_log');
        renderLog();
        markActivity();
        maybeRerenderChart();
      }
    }

    /* ========= Toggles ========= */
    function setBadge(el, isOn, labelOn, labelOff){
      el.textContent = isOn ? labelOn : labelOff;
      el.classList.remove('on','off'); el.classList.add(isOn ? 'on' : 'off');
    }
    function toggleMuteSound() {
      muteSound = !muteSound; localStorage.setItem('muteSound', JSON.stringify(muteSound));
      document.getElementById('muteSoundBtn').textContent = muteSound ? 'Unmute Sound' : 'Mute Sound';
      setBadge(document.getElementById('muteSoundBadge'), !muteSound, 'Sound: On', 'Sound: Off');
      if (muteSound) {
        const ding = document.getElementById('ding');
        if (!ding.paused) ding.pause();
        if (dingTimeout) { clearTimeout(dingTimeout); dingTimeout = null; }
      }
    }
    function toggleMuteNotifications() {
      muteNotifications = !muteNotifications; localStorage.setItem('muteNotifications', JSON.stringify(muteNotifications));
      document.getElementById('muteNotifBtn').textContent = muteNotifications ? 'Enable Notifications' : 'Disable Notifications';
      setBadge(document.getElementById('muteNotifBadge'), !muteNotifications, 'Notifications: On', 'Notifications: Off');
    }
    function toggleMuteReminders() {
      muteReminders = !muteReminders; localStorage.setItem('muteReminders', JSON.stringify(muteReminders));
      document.getElementById('muteRemindersBtn').textContent = muteReminders ? 'Unmute Reminders' : 'Mute Reminders';
      setBadge(document.getElementById('muteRemindersBadge'), !muteReminders, 'Reminders: On', 'Reminders: Off');
    }

    /* ========= Idle Reminder (only when NO timer running) ========= */
    let nextReminderEstimateEl = null;
    function msSinceLastActivity() { return Date.now() - lastTimerActivity; }
    function updateNextReminderEstimate() {
      if (!nextReminderEstimateEl) nextReminderEstimateEl = document.getElementById('nextReminderETA');
      const noTimerRunning = (timer === null);
      if (!noTimerRunning || muteReminders || !inParisWorkWindows()) {
        nextReminderEstimateEl.textContent = '';
        return;
      }
      const remainingMs = Math.max(0, (20*60*1000) - msSinceLastActivity());
      const m = String(Math.floor(remainingMs / 60000)).padStart(2,'0');
      const s = String(Math.floor((remainingMs % 60000) / 1000)).padStart(2,'0');
      nextReminderEstimateEl.textContent = remainingMs === 0 ? 'Reminder eligible now.' : `Next reminder in ~${m}:${s}`;
    }
    function maybeSendIdleReminder() {
      const noTimerRunning = (timer === null);
      if (noTimerRunning && !muteReminders && inParisWorkWindows()) {
        if (msSinceLastActivity() >= 20*60*1000) {
          if (!muteNotifications && typeof Notification !== 'undefined') {
            if (Notification.permission !== 'granted') Notification.requestPermission();
            if (Notification.permission === 'granted') new Notification('Reminder: no timer running', { body: 'Start a timer?' });
          }
          markActivity(); // reset so we don’t spam
        }
      }
      updateNextReminderEstimate();
      scheduleNextIdleCheck();
    }
    function scheduleNextIdleCheck(delayMs = 60*1000) {
      if (idleCheckHandle) clearTimeout(idleCheckHandle);
      idleCheckHandle = setTimeout(maybeSendIdleReminder, delayMs);
    }

    /* ========= Modal: Add/Edit ========= */
    function openEditModal(id) {
      const log = JSON.parse(localStorage.getItem('time_log') || '[]');
      const entry = log.find(x => x.id === id);
      if (!entry) return alert('Entry not found.');
      modalMode = 'edit'; modalEditingId = id;
      document.getElementById('modalTitle').textContent = 'Edit Session';
      document.getElementById('modalDeleteBtn').style.display = '';
      document.getElementById('modalTask').value = entry.task || '';
      document.getElementById('modalStart').value = (entry.start || '').replace(' UTC','');
      document.getElementById('modalEnd').value = (entry.end || '').replace(' UTC','');
      openModal();
    }
    function openAddModal() {
      modalMode = 'add'; modalEditingId = null;
      document.getElementById('modalTitle').textContent = 'Add Past Session';
      document.getElementById('modalDeleteBtn').style.display = 'none';
      document.getElementById('modalTask').value = '';
      document.getElementById('modalStart').value = '';
      document.getElementById('modalEnd').value = '';
      openModal();
    }
    function openModal(){ document.getElementById('modalBackdrop').style.display = 'grid'; }
    function closeModal(){ document.getElementById('modalBackdrop').style.display = 'none'; }
    function saveModal() {
      const task = document.getElementById('modalTask').value.trim();
      const startStr = document.getElementById('modalStart').value.trim();
      const endStr = document.getElementById('modalEnd').value.trim();
      if (!task) return alert('Task is required.');
      const startDt = parseUTCString(startStr);
      const endDt = parseUTCString(endStr);
      if (!startDt || !endDt) return alert('Please enter valid UTC times: YYYY-MM-DD HH:MM:SS');
      if (endDt <= startDt) return alert('End must be after Start.');

      const duration = durationStringFromDates(startDt, endDt);
      const payload = { task, duration, start: formatExcelDateString(startDt) + ' UTC', end: formatExcelDateString(endDt) + ' UTC' };

      const log = JSON.parse(localStorage.getItem('time_log') || '[]');
      ensureIdsOnLog(log);
      if (modalMode === 'edit') {
        const idx = findLogIndexById(modalEditingId);
        if (idx === -1) return alert('Entry not found.');
        payload.id = log[idx].id; log[idx] = payload;
      } else {
        payload.id = 's_' + Date.now() + '_' + Math.random().toString(36).slice(2,8);
        log.push(payload);
      }
      localStorage.setItem('time_log', JSON.stringify(log));
      closeModal(); renderLog(); maybeRerenderChart();
    }
    function deleteSessionFromModal() {
      if (!confirm('Delete this session?')) return;
      const log = JSON.parse(localStorage.getItem('time_log') || '[]');
      const idx = findLogIndexById(modalEditingId);
      if (idx === -1) return alert('Entry not found.');
      log.splice(idx, 1);
      localStorage.setItem('time_log', JSON.stringify(log));
      closeModal(); renderLog(); maybeRerenderChart();
    }

    /* ========= Chart: Last Five Weekdays ========= */
    function toggleChart() {
      const wrap = document.getElementById('chartWrap');
      if (wrap.style.display === 'none' || wrap.style.display === '') { wrap.style.display = 'block'; renderBarChartForLastFiveWeekdays(); }
      else { wrap.style.display = 'none'; }
    }
    function maybeRerenderChart() {
      const wrap = document.getElementById('chartWrap');
      if (wrap.style.display !== 'none') renderBarChartForLastFiveWeekdays();
    }
    function parseDurationToMinutes(durStr) {
      const [m, s] = String(durStr).split(':').map(x => parseInt(x, 10) || 0);
      return m + s / 60;
    }
    function getLastNWeekdays(n, tz) {
      const out = [];
      let cursor = new Date(new Date().toLocaleString('en-US', { timeZone: tz }));
      cursor.setHours(12,0,0,0);
      while (out.length < n) {
        const day = cursor.getDay(); // 0 Sun .. 6 Sat
        if (day >= 1 && day <= 5) out.push(ymdInTZ(cursor, tz));
        cursor.setDate(cursor.getDate() - 1);
      }
      return out.reverse();
    }
    function totalsForDates(dateKeys, tz) {
      const totals = {}; dateKeys.forEach(k => totals[k] = 0);
      const log = JSON.parse(localStorage.getItem('time_log') || '[]');
      for (const row of log) {
        if (!row.start || !row.duration) continue;
        const raw = row.start.replace(' UTC','');
        const d = parseUTCString(raw);
        const key = ymdInTZ(d, tz);
        if (key in totals) totals[key] += parseDurationToMinutes(row.duration);
      }
      return totals;
    }
    function renderBarChartForLastFiveWeekdays() {
      const tz = displayTZ;
      const dates = getLastNWeekdays(5, tz);
      const totals = totalsForDates(dates, tz);
      const labels = dates.map(d => d.slice(5));
      const values = dates.map(d => Math.round((totals[d] || 0) * 10) / 10);
      drawBars(labels, values);
    }
    function drawBars(labels, values) {
      const canvas = document.getElementById('barChart');
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;

      ctx.clearRect(0,0,W,H);
      const margin = { left: 56, right: 24, top: 28, bottom: 56 };
      const chartW = W - margin.left - margin.right;
      const chartH = H - margin.top - margin.bottom;

      // Axes
      ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(margin.left, margin.top);
      ctx.lineTo(margin.left, margin.top + chartH);
      ctx.lineTo(margin.left + chartW, margin.top + chartH);
      ctx.stroke();

      // Scale
      const maxVal = Math.max(0, ...values);
      const niceMax = maxVal === 0 ? 60 : Math.ceil(maxVal / 30) * 30;
      const toY = (v) => margin.top + chartH - (v / niceMax) * chartH;

      // Grid + Y labels
      const textColor = getComputedStyle(document.body).getPropertyValue('--muted');
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif';
      for (let y=0; y<=niceMax; y+=30) {
        const yy = toY(y);
        ctx.strokeStyle = 'rgba(125,125,125,.12)';
        ctx.beginPath(); ctx.moveTo(margin.left, yy); ctx.lineTo(margin.left + chartW, yy); ctx.stroke();
        ctx.fillStyle = textColor;
        const hrs = Math.floor(y/60), mins = y%60;
        const label = hrs>0 ? `${hrs}h${String(mins).padStart(2,'0')}` : `${mins}m`;
        ctx.fillText(label, 8, yy+4);
      }

      // Bars
      const n = labels.length; const gap = 18;
      const barW = Math.min(72, (chartW - gap*(n+1)) / n);
      let x = margin.left + gap;

      const barFill = getComputedStyle(document.body).getPropertyValue('--primary');
      const barStroke = getComputedStyle(document.body).getPropertyValue('--primary-600');

      for (let i=0;i<n;i++){
        const v = values[i], y = toY(v), h = (margin.top+chartH) - y;
        ctx.fillStyle = barFill; ctx.globalAlpha = .85; ctx.fillRect(x, y, barW, h); ctx.globalAlpha = 1;
        ctx.strokeStyle = barStroke; ctx.strokeRect(x+.5, y+.5, barW-1, h-1);

        const totMin = Math.round(v);
        const hh = Math.floor(totMin/60), mm = totMin%60;
        const valLabel = hh>0 ? `${hh}:${String(mm).padStart(2,'0')}` : `${mm}m`;
        ctx.textAlign = 'center';
        if (h>18){ ctx.fillStyle = '#fff'; ctx.fillText(valLabel, x+barW/2, y+14); }
        else { ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text'); ctx.fillText(valLabel, x+barW/2, y-6); }

        const textColor2 = getComputedStyle(document.body).getPropertyValue('--muted');
        ctx.fillStyle = textColor2;
        ctx.fillText(labels[i], x+barW/2, margin.top+chartH+18);

        x += barW + gap;
      }

      const note = document.getElementById('chartNote');
      note.innerHTML = `Minutes per day for the last five weekdays (grouped by <strong>${displayTZ}</strong> day, using each session’s <em>start time</em>).`;
    }

    /* ========= Timezone UI ========= */
    function applyTimezone() {
      const input = document.getElementById('tzInput').value.trim();
      if (!input) return;
      if (!isValidTimeZone(input)) {
        alert('That does not look like a valid IANA timezone.\nExamples: UTC, Europe/Paris, America/New_York');
        return;
      }
      displayTZ = input;
      localStorage.setItem('displayTZ', displayTZ);
      updateTZUI();
      renderLog();
      maybeRerenderChart();
    }
    function useSystemTimezone() {
      displayTZ = getSystemTZ();
      localStorage.setItem('displayTZ', displayTZ);
      updateTZUI();
      renderLog();
      maybeRerenderChart();
    }
    function updateTZUI() {
      document.getElementById('tzBadge').textContent = `TZ: ${displayTZ}`;
      document.getElementById('tzInput').value = displayTZ;
      document.getElementById('startHeader').textContent = `Start (${displayTZ})`;
      document.getElementById('endHeader').textContent = `End (${displayTZ})`;
      const note = document.getElementById('chartNote');
      if (note) note.innerHTML = `Minutes per day for the last five weekdays (grouped by <strong>${displayTZ}</strong> day, using each session’s <em>start time</em>).`;
    }

    /* ========= Init ========= */
    (function initUI(){
      document.getElementById('muteSoundBtn').textContent = muteSound ? 'Unmute Sound' : 'Mute Sound';
      setBadge(document.getElementById('muteSoundBadge'), !muteSound, 'Sound: On', 'Sound: Off');

      document.getElementById('muteNotifBtn').textContent = muteNotifications ? 'Enable Notifications' : 'Disable Notifications';
      setBadge(document.getElementById('muteNotifBadge'), !muteNotifications, 'Notifications: On', 'Notifications: Off');

      document.getElementById('muteRemindersBtn').textContent = muteReminders ? 'Unmute Reminders' : 'Mute Reminders';
      setBadge(document.getElementById('muteRemindersBadge'), !muteReminders, 'Reminders: On', 'Reminders: Off');

      updateTZUI();

      if (!localStorage.getItem('lastTimerActivity')) { markActivity(); }
      else { lastTimerActivity = parseInt(localStorage.getItem('lastTimerActivity'), 10) || Date.now(); }

      if (!muteNotifications && typeof Notification !== 'undefined' && Notification.permission !== 'granted') {
        Notification.requestPermission();
      }

      renderLog();

      restoreActiveTimer();

      updateNextReminderEstimate();
      scheduleNextIdleCheck(60*1000);
      document.addEventListener('visibilitychange', () => {
        updateNextReminderEstimate();
        if (!document.hidden) scheduleNextIdleCheck(2*1000);
      });

      document.addEventListener('keydown', e => { if (e.key === 'Escape') closeModal(); });
      document.getElementById('modalBackdrop').addEventListener('click', e => {
        if (e.target.id === 'modalBackdrop') closeModal();
      });
    })();
  </script>
</body>
</html>
